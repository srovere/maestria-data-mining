---
title: "Enfoque estadístico del aprendizaje: Trabajo Práctico nº 2"
subtitle: "Análisis de un conjunto de datos de Properati"
author:
- Santiago Rovere (srovere@gmail.com), Facultad de Ingeniería, Universidad de Buenos Aires
date: '`r format(Sys.Date(), "%d de %B de %Y")`'
output:
  html_document:
    toc: TRUE
    toc_float: TRUE
    theme: flatly
    css: styles.css
lang: es
---

# Lectura de datos

Se comienza el análisis propuesto cargando los paquetes necesarios, leyendo el conjunto de datos y mostrando la estructura del mismo a fin de conocer los atributos sobre los que se van a trabajar. Se elimina el atributo *id* y se transforman a factores las variables *l3* y *property_type*.

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
# Borrar variables del ambiente
rm(list = objects())

# Carga de paquetes necesarios para hacer los gráficos
require(Cairo)
require(GGally)
require(ggpubr)
require(Hmisc)
require(knitr)
require(tidyverse)

# Uso de Cairo para renderizar los gráficos.
options(bitmapType = "cairo")

# Cargar conjunto de datos de precios de propiedades. 
# Pasamos
datos <- base::readRDS(file = "ar_properties.rds") %>%
  dplyr::mutate(l3 = as.factor(l3), property_type = as.factor(property_type)) %>%
  dplyr::select(-id)

# Mostrar estructura
head(datos)
```

# Regresión lineal múltiple

## Creación del modelo

Se procede a crear el modelo con las variables propuestas, dos de las cuales (*property_type* y *l3*) son categóricas. La función **lm** automáticamente maneja estas variables transformándolas en N-1 *dummies* para el caso de factores con N niveles.

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
# Ajustamos un modelo lineal múltiple
modelo.multiple.1 <- stats::lm(formula = price ~ ., data = datos)

# Pasamos los coeficientes a un data.frame para trabajarlos mejor
tabla.modelo.multiple.1 <- broom::tidy(modelo.multiple.1)

# Mostramos las métricas del modelo
summary(modelo.multiple.1)
```

## Análisis del modelo

El valor de $R^2$ es de aproximadamente 0.78, lo que implica que se explica el 78% de la variable de respuesta. Las variables categóricas *l3* y *property_type* fueron automáticamente transformadas en *dummies* a efecto de poder ser ajustadas por el modelo lineal. A fin de evitar problemas de multicolinealidad, las variables con *N* categorías fueron transformadas en *N-1* atributos binarios. En el caso del atributo *l3*, se observa que el barrio de *Abasto* no figura como dummy, así como también sucede con el caso de las *casas* para el atributo *property_type*. Esto significa que si todas las variables dummies valen 0, el modelo lineal resultante es aplicable a casas del barrio de Abasto. A continuación se analizarán respectivamente los coeficientes asociados a las variables numéricas, dummies asociadas a *property_type* y dummies asociadas a *l3*.

### Análisis de coeficientes de variables numéricas

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
knitr::kable(
  dplyr::filter(tabla.modelo.multiple.1, 
                is.na(stringr::str_match(term, "l3")) &
                is.na(stringr::str_match(term, "property_type")))
)
```

Se observa que todos los coeficientes asociados a variables numéricas son altamente significativos, al igual que el *intercept* ($\beta_0$). Los valores de los coeficientes asociados a cantidad de baños y superficie (total y cubierta) son positivos, indicando un incremento en el precio esperado de acuerdo al monto indicado por cada coeficiente por cada incremento en una unidad de cada variable. Esto es sumamente lógico y esperable. Incluso se observa que el coeficiente asociado a la superficie cubierta es mayor que el asociado a la superficie total, lo cual indica que aumentar una unidad en el valor de la superficie subierta aumenta el precio más que incrementar una unidad la superficie total (sin distinción de tipo).

Sin embargo, el coeficiente asociado a la cantidad de habitaciones es negativo, indicando que el incremento en una unidad en la cantidad de habitaciones produce una disminución en el precio del inmueble. A priori, esto no era esperable, dado que el precio y la cantidad de habitaciones tiene correlación positiva.

### Análisis de coeficientes para tipos de propiedad

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
knitr::kable(
  dplyr::filter(tabla.modelo.multiple.1, 
                ! is.na(stringr::str_match(term, "property_type"))) %>%
  dplyr::mutate(property_type = stringr::str_match(term, "property_type(.+)")[,2]) %>%
  dplyr::select(property_type, estimate, std.error, statistic, p.value)
)
```

En el caso del tipo de propiedad, vemos que en ambos casos los coeficientes asociados son altamente significativos y positivos. El valor de cada uno de los coeficientes indica el incremento en el precio esperado de un departamento o PH respecto de una casa que está en el mismo barrio y tiene exactamente los mismos valores de superficie total, cubierta, cantidad de cuartos y cantidad de baños.

### Análisis de coeficientes para barrios

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
knitr::kable(
  dplyr::filter(tabla.modelo.multiple.1, 
                ! is.na(stringr::str_match(term, "l3"))) %>%
  dplyr::mutate(l3 = stringr::str_match(term, "l3(.+)")[,2]) %>%
  dplyr::select(l3, estimate, std.error, statistic, p.value) %>%
  dplyr::arrange(estimate)
)
```

Finalmente, se analizan los coeficientes asociados a los barrios. Hay varios que son altamente significativos, otros que son significativos y algunos que directamente no lo son. Para el caso de los coeficientes que son significativos (o muy significativos), la interpretación es análoga que para el tipo de propiedad. Es decir, que los mismos representan el incremento en el precio esperado de una propiedad que está en un barrio determinado respecto de otra del mismo tipo (casa, depertamento o PH) ubicada en *Abasto* y con los mismos valores de superficie total, cubierta, cantidad de cuartos y cantidad de baños.

Para el caso de los coeficientes que no son significativos, la interpretación que se puede dar es que el precio esperado de una propiedad ubicada en uno de esos barrios no es significativamente diferente al de otra propiedad con las mismas características ubicado en Abasto. Esto sucede porque el test de hipótesis con $H_0$: $\beta_i$ = 0, no puede rechazar la hipótesis con el nivel de significacion de 0.05.

## Comparación de predicciones para dos casos particulares.

En las consignas se platea determinar cuál de las siguientes dos opciones es más conveniente para vender:

  * Un departamento de 120 mts cuadrados cubiertos en abasto, con 3 dormitorios y 2 baños.
  * Un PH en balvanera, con 80 mts cuadrados cubiertos, 20 mts cuadrados no cubiertos, 2 dormitorios y 3 baños.
  
```{r, echo=TRUE, warnings=FALSE, message=FALSE }
caso.1 <- data.frame(
  l3 = "Abasto",
  property_type = "Departamento",
  property_type_PH = 0,
  surface_total = 120, 
  surface_covered = 120, 
  rooms = 3, 
  bathrooms = 2
)
print("Caso 1:")
predict(modelo.multiple.1, caso.1, interval = "predict")

caso.2 <- data.frame(
  l3 = "Balvanera",
  property_type = "PH",
  surface_total = 100, 
  surface_covered = 80, 
  rooms = 2, 
  bathrooms = 3
)
print("Caso 2:")
predict(modelo.multiple.1, caso.2, interval = "predict")
```  

Se observa entonces que el valor esperado para el precio del caso 1 (departamento ubicado en Abasto) es significativamente superior al del segundo caso, por lo que lo torna más preferible en términos de monto.

## Realización de otro modelo sin *l3*

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
# Ajustamos un modelo lineal múltiple sin considerar l3
modelo.multiple.2 <- stats::lm(formula = price ~ ., data = dplyr::select(datos, -l3))

# Mostramos las métricas del modelo
summary(modelo.multiple.2)
```

TODO

# Creación de variables

Se creará un nuevo modelo que en vez de considerar los barrios, considere grupos de barrios agrupados en 3 categorías de acuerdo al precio promedio del metro cuadrado. A continuación analizar los puntos de corte.

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
datos.precio.m2.barrio <- datos %>%
  dplyr::mutate(price_m2 = price / surface_total) %>%
  dplyr::group_by(l3) %>%
  dplyr::summarise(mean_price_m2 = mean(price_m2), 
                   cantidad = dplyr::n()) %>%
  dplyr::arrange(mean_price_m2)

knitr::kable(datos.precio.m2.barrio)
```

Inicialmente se podría pensar que la clasificación de los barrios por precio promedio del metro cuadrado se podría obtener separando por terciles considerando los precios de la tabla anterior. Dado que hay 57 barrios, obtendríamos 3 categorías cada unas de las cuales agruparía 19 barrios. Sin embargo, las categorías *alto*, *medio* y *bajo* contendrían una cantidad muy dispar de propiedades, a saber:

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
cantidad.propiedades <- dplyr::pull(datos.precio.m2.barrio, cantidad)
cat(sprintf("Cantidad de propiedades (bajo): %d\n", sum(cantidad.propiedades[1:19])))
cat(sprintf("Cantidad de propiedades (medio): %d\n", sum(cantidad.propiedades[20:38])))
cat(sprintf("Cantidad de propiedades (alto): %d\n", sum(cantidad.propiedades[39:57])))
```

Esto se debe a que los barrios con mayor cantidad de propiedades son aquellos con precios promedio del metro cuadrado más elevado. Para obtener una categorización más equilibrada en cantidad de casos, reagrupamos utilizando el siguiente criterio:

  * Se considera la tabla ordenada de precios por metro cuadrado como en el caso inicial.
  * Dado que hay 45.904 propiedades, se buscan grupos que contengan cada uno de ellos aproximadamente la tercera parte de la población de propiedades (aproximadamente 15.301 propiedades).
  
De este modo, obtenemos los siguientes grupos:

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
# Creamos los grupos
grupos.barrios <- datos.precio.m2.barrio %>%
  dplyr::mutate(
    cantidad_acumulada = cumsum(cantidad),
    barrio = dplyr::case_when(
      cantidad_acumulada <= (nrow(datos) / 3) ~ "Bajo",
      cantidad_acumulada <= (2 * nrow(datos) / 3) ~ "Medio",
      TRUE ~ "Alto"
    )
  ) %>% dplyr::mutate(barrio = factor(barrio, c("Medio", "Bajo", "Alto")))

knitr::kable(datos.precio.m2.barrio)

# Ahora generamos el nuevo set de datos
datos.barrios <- datos %>%
  dplyr::inner_join(grupos.barrios, by = c("l3")) %>%
  dplyr::select(-l3, -mean_price_m2, -cantidad, -cantidad_acumulada)
```

Si bien la distribución no es exacta, es bastante más pareja que en el caso inicial. A continuación se procede a realizar otro modelo en base a este nuevo conjunto de datos.

## Modelo basado en barrios agrupados según el precio del metro cuadrado

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
# Ajustamos un modelo lineal múltiple
modelo.multiple.3 <- stats::lm(formula = price ~ ., data = datos.barrios)

# Mostramos las métricas del modelo
summary(modelo.multiple.3)
```

De acuerdo a la salida, se observa que el valor de $R^2$ es de aproximadamente 0.75, en contraposición al valor de 0.78 observado en el modelo con todos los barrios. Todas las variables resultan altamente significativas, observándose el mismo patrón de signo para las variables numéricas que para el caso con todos los barrios. También se observa que el coeficiente asociado a la superficie cubierta es mayor que aquel asociado a la superficie total. Los coeficientes para los tipo de propiedad siguen siendo positivos, siendo el mayor de ellos el asociado a departamentos (también al igual que para el caso inicial).

Lo nuevo que aparece en este caso son los coeficientes asociados a las propiedades de precio alto y bajo. Se eligió adrede como primera categoría del factor a la clase *media* a fin de que fuera eliminada y se pudieran comparar los coeficientes asociado a las otras dos en relación a la primera. Se observa que las propiedades de barrios de categoría *baja* tienen efectivamente un coeficiente negativo y los de categoría *alta* un coeficiente positivo. Este coeficiente indica el monto en el cual se incrementa (o disminuye) el precio esperado de una propiedad de en barrio de cierta categoría en relación a otra de categoría media, del mismo tipo (departamento, casa o PH) y con los mismos parámetros de superficie total, cubierta, cantidad de habitaciones y de baños.

Si bien este modelo tiene un $R^2$ ajustado muy levemente menor al original, tiene la ventaja de ser mucho más simple, dado que tiene una cantidad significativamente menor de covariables. Siguiendo el principio de la navaja de Ockham, se podría decir que este modelo es preferible al inicial, teniendo en cuenta la consideración previa. 

## Creación de variable surface_patio

Definimos la variable *surface_patio*. En ningún caso se observa que surface_covered < surface_total. Esos casos como éstos optaría por eliminar las observaciones (en casos de ser pocas), dado que es información errónea.

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
# construimos el nuevo set de datos, segun se indica.
datos.patio <- datos.barrios %>%
  dplyr::mutate(surface_patio = surface_total - surface_covered) %>%
  dplyr::select(-surface_total)

# Ajustamos un modelo lineal múltiple
modelo.multiple.4 <- stats::lm(formula = price ~ ., data = datos.patio)

# Mostramos las métricas del modelo
summary(modelo.multiple.4)
```

## Análisis e interpretación del nuevo modelo

# Evaluación del modelo

## Análisis de residuos del modelo anterior

```{r, echo=TRUE, warnings=FALSE, message=FALSE, height=10 }
# Obtencion de residuos
residuos.modelo.4 <- datos.patio %>%
  dplyr::mutate(valor_ajustado = modelo.multiple.4$fitted.values,
                residuo = modelo.multiple.4$residuals)
  
# Generacion de QQ-plot
qq.residuos.general <- ggplot2::ggplot(data = residuos.modelo.4) +
  ggplot2::geom_qq_line(mapping = ggplot2::aes(sample = scale(residuo)), col = 'red') +
  ggplot2::geom_qq(mapping = ggplot2::aes(sample = scale(residuo)), col = "darkslategray4", size = 0.2) +
  ggplot2::labs(x = "Cuantiles teóricos", y = "Residuos estandarizados", 
                title = "QQ-plot de residuos estandarizados",
                subtitle = "Análisis de normalidad de los residuos") +
  ggplot2::theme_bw() +
  ggplot2::theme(
    plot.title = ggplot2::element_text(hjust = 0.5),
    plot.subtitle = ggplot2::element_text(hjust = 0.5)
  )
plot(qq.residuos.general)
```

```{r, echo=TRUE, warnings=FALSE, message=FALSE, height=10 }
# Generación de gráfico de Scale-Location
sl.residuos.general <- ggplot2::ggplot(data = residuos.modelo.4) +
  ggplot2::geom_hline(yintercept = mean(residuos.modelo.4$residuo), col = "red") +
  ggplot2::geom_point(mapping = ggplot2::aes(x = valor_ajustado, y = residuo), col = "darkslategray4") +
  ggplot2::labs(x = "Valores ajustados", y = "Residuos", 
                title = "Gráfico de Scale-Location",
                subtitle = "Análisis de la homocedasticidad de los residuos") +
  ggplot2::theme_bw() +
  ggplot2::theme(
    plot.title = ggplot2::element_text(hjust = 0.5),
    plot.subtitle = ggplot2::element_text(hjust = 0.5)
  )
plot(sl.residuos.general)
```

## Análisis de nuevo modelo

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
# Ajustamos un modelo lineal múltiple de acuerdo a lo indicado
modelo.multiple.5 <- stats::lm(formula = log(price) ~ log(rooms)+log(bathrooms)+log(surface_covered)+property_type+barrio+surface_patio, 
                               data = datos.patio)

# Mostramos las métricas del modelo
summary(modelo.multiple.5)
```

```{r, echo=TRUE, warnings=FALSE, message=FALSE, height=10 }
# Obtencion de residuos
residuos.modelo.5 <- datos.patio %>%
  dplyr::mutate(valor_ajustado = modelo.multiple.5$fitted.values,
                residuo = modelo.multiple.5$residuals)
  
# Generacion de QQ-plot
qq.residuos.general <- ggplot2::ggplot(data = residuos.modelo.5) +
  ggplot2::geom_qq_line(mapping = ggplot2::aes(sample = scale(residuo)), col = 'red') +
  ggplot2::geom_qq(mapping = ggplot2::aes(sample = scale(residuo)), col = "darkslategray4", size = 0.2) +
  ggplot2::labs(x = "Cuantiles teóricos", y = "Residuos estandarizados", 
                title = "QQ-plot de residuos estandarizados",
                subtitle = "Análisis de normalidad de los residuos") +
  ggplot2::theme_bw() +
  ggplot2::theme(
    plot.title = ggplot2::element_text(hjust = 0.5),
    plot.subtitle = ggplot2::element_text(hjust = 0.5)
  )
plot(qq.residuos.general)
```

```{r, echo=TRUE, warnings=FALSE, message=FALSE, height=10 }
# Generación de gráfico de Scale-Location
sl.residuos.general <- ggplot2::ggplot(data = residuos.modelo.5) +
  ggplot2::geom_hline(yintercept = mean(residuos.modelo.4$residuo), col = "red") +
  ggplot2::geom_point(mapping = ggplot2::aes(x = valor_ajustado, y = residuo), col = "darkslategray4") +
  ggplot2::labs(x = "Valores ajustados", y = "Residuos", 
                title = "Gráfico de Scale-Location",
                subtitle = "Análisis de la homocedasticidad de los residuos") +
  ggplot2::theme_bw() +
  ggplot2::theme(
    plot.title = ggplot2::element_text(hjust = 0.5),
    plot.subtitle = ggplot2::element_text(hjust = 0.5)
  )
plot(sl.residuos.general)
```