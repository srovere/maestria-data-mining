---
title: "Enfoque estadístico del aprendizaje: Trabajo Práctico nº 1"
subtitle: "Análisis de un conjunto de datos de Properati"
author:
- Santiago Rovere (srovere@gmail.com), Facultad de Ingeniería, Universidad de Buenos Aires
date: '`r format(Sys.Date(), "%d de %B de %Y")`'
output:
  html_document:
    toc: TRUE
    toc_float: TRUE
    theme: flatly
    css: styles.css
lang: es
---

# Lectura de datos

Se comienza el análisis propuesto cargando los paquetes necesarios, leyendo el conjunto de datos y mostrando la estructura del mismo a fin de conocer los atributos sobre los que se van a trabajar.

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
# Borrar variables del ambiente
rm(list = objects())

# Carga de paquetes necesarios para hacer los gráficos
require(Cairo)
require(GGally)
require(ggpubr)
require(knitr)
require(tidyverse)

# Uso de Cairo para renderizar los gráficos
options(bitmapType = "cairo")

# Cargar conjunto de datos
datos <- readr::read_csv(file = "ar_properties.csv")

# Mostrar estructura
head(datos)
```

A continuación, seleccionamos los datos indicados en las consignas del TP, los cuales se encuentran documentados en el código.

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
datos.seleccionados <- datos %>%
  dplyr::filter(
    # propiedades de Capital Federal / Argentina
    (l1 == "Argentina" & l2 == "Capital Federal") &
    # cuyo precio está en dólares
    (currency == "USD") &                                  
     # cuyo tipo sea Departamento, PH o Casa
    (property_type %in% c("Departamento", "PH", "Casa")) &
    # y que sean publicadas para Venta
    (operation_type == "Venta")                            
  ) %>%
  dplyr::select(id, l3, rooms, bedrooms, bathrooms, surface_total, 
                surface_covered, price, property_type)
```

# Análisis exploratorio (I)

Realizamos un primer análisis exploratorio buscando la cantidad de valores únicos y faltantes para cada variable.

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
resumen.cantidad <- purrr::map_dfr(
  .x = colnames(datos.seleccionados),
  .f = function(variable) {
    # Seleccionamos los datos para una variable
    valores.variable <- datos.seleccionados %>%
      dplyr::pull(!! variable)
    
    # Calculamos la cantidad de valores únicos y de valores faltantes
    return (
      data.frame(
        variable = variable, 
        cantidad_unicos = length(unique(valores.variable)),
        cantidad_faltantes = length(which(is.na(valores.variable))),
        stringsAsFactors = FALSE
      )
    )
  }
)

# Mostramos una tabla con los valores calculados
knitr::kable(
  x = resumen.cantidad,
  col.names = c("Variable", "Cantidad de valores únicos", 
                "Cantidad de valores faltantes"),
  align = c("l", "r", "r")
)
```

También calculamos la matriz de correlación para las variables numéricas a fin de detectar atributos muy correlacionados (y eventualmente eliminarlos).

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
# Primero buscamos las variables numéricas
variables.numericas <- purrr::map(
  .x = colnames(datos.seleccionados),
  .f = function(variable) {
    # Si la variable tiene todos sus valores numéricos, devolvemos el nombre de la variable, sino NA.
    return (ifelse(is.numeric(datos.seleccionados[[variable]]), variable, NA))
  }
) %>% purrr::keep(
  # Eliminamos todos los NA devueltos en el paso anterior.
  .x = .,
  .p = ~ ! is.na(.x)
) %>% unlist()

# Ahora seleccionamos esas variable y calculamos la matriz de correlación
datos.seleccionados.variables.numericas <- datos.seleccionados %>%
  dplyr::select(dplyr::one_of(variables.numericas))
matriz.correlacion <- stats::cor(datos.seleccionados.variables.numericas, 
                                 use = "complete.obs")

# Mostramos una tabla considerando 3 dígitos decimales
knitr::kable(
  x = matriz.correlacion,
  digits = 3
)
```

# Preparación de datos

Dado que la variable **bedrooms** contiene una alta proporción de valores faltantes y está altamente correlacionada con la variable **rooms**, entonces la eliminamos. Posteriormente, también eliminamos todas las observaciones que contengan algún dato faltante.

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
datos.sin.faltantes <- datos.seleccionados %>%
  # Elimino el atributo bedrooms
  dplyr::select(-bedrooms) %>%
  # Calculo la cantidad de faltantes para cada observación
  dplyr::mutate(
    faltantes = purrr::pmap(
      .l = .,
      .f = function(...) {
        # Devuelvo la cantidad de columnas que tienen atributo faltante
        columnas <- list(...)
        return (length(which(is.na(columnas))))
      }
    ) %>% unlist()
  ) %>%
  # Me quedo con las observaciones sin faltantes
  dplyr::filter(faltantes == 0) %>%
  # Elimino el atributo "faltantes"
  dplyr::select(-faltantes)

# Eliminamos bedrooms de las variables numéricas
variables.numericas <- variables.numericas[-which(variables.numericas == "bedrooms")]
```

# Analisis exploratorios (II)

Con el conjunto de datos resultantes luego de este primer filtrado, calculamos estadísticas descriptivas para la variable **precio** y realizamos un histograma de su distribución. Dado que hay algunos precios que son muy elevados, mostramos los precios en escala logarítmica para que la forma del histograma pueda apreciarse mejor.

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
# Realizamos una tabla con las estadísticas descriptivas
cuartiles.precio                 <- quantile(datos.sin.faltantes$price, 
                                             probs = c(0.25, 0.5, 0.75))
estadisticas.descriptivas.precio <- datos.sin.faltantes %>%
  dplyr::summarise(
    Mínimo = min(price), 
    Q1 = cuartiles.precio[1], 
    Mediana = cuartiles.precio[2],
    Media = mean(price), 
    Q3 = cuartiles.precio[3],
    Máximo = max(price)
  )

knitr::kable(
  x = estadisticas.descriptivas.precio,
  digits = 3
)
```

```{r, echo=TRUE, warnings=FALSE, message=FALSE, fig.align='center', fig.width=8 }
# Y ahora el histograma
ggplot2::ggplot(data = datos.sin.faltantes) +
  ggplot2::geom_histogram(mapping = ggplot2::aes(x = price/1000), 
                          fill = "darkslategray4") +
  ggplot2::scale_x_log10() +
  ggplot2::labs(x = "Precio (en miles de USD)", y = "Frecuencia", 
                title = "Histograma para la variable precio",
                subtitle = "Valores en escala logarítmica") +
  ggplot2::theme_bw() +
  ggplot2::theme(
    plot.title = ggplot2::element_text(hjust = 0.5),
    plot.subtitle = ggplot2::element_text(hjust = 0.5),
  )
```

A continuación, hacemos el mismo análisis pero separando las propiedades por tipo (atributo **property_type**). Vemos que hay diferencias de precio notables para las *casas* en comparación con otros tipos de propiedades.

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
# Realizamos una tabla con las estadísticas descriptivas
estadisticas.descriptivas.precio.tipo.propiedad <- purrr::map_dfr(
  .x = unique(datos.sin.faltantes$property_type),
  .f = function(tipo_propiedad) {
    datos.tipo.propiedad                  <- datos.sin.faltantes %>%
      dplyr::filter(property_type == tipo_propiedad)
    cuartiles.precio.tipo                 <- quantile(datos.tipo.propiedad$price,
                                                      probs = c(0.25, 0.5, 0.75))
    estadisticas.descriptivas.precio.tipo <- datos.tipo.propiedad %>%
      dplyr::summarise(
        Tipo = tipo_propiedad,
        Mínimo = min(price), 
        Q1 = cuartiles.precio.tipo[1], 
        Mediana = cuartiles.precio.tipo[2],
        Media = mean(price), 
        Q3 = cuartiles.precio.tipo[3],
        Máximo = max(price)
      )
  }
)

knitr::kable(
  x = estadisticas.descriptivas.precio.tipo.propiedad,
  digits = 3
)
```

Para cada tipo de propiedad, elaboramos un boxplot. Se observan una cantidad importante de propiedades con precios atípicos (outliers) para cada tipo de propiedad. Sin embargo, eso no significa que esos valores sean erróneos, pero vamos a tener que tenerlo en cuenta más adelante cuando se ajusten los modelos lineales.

```{r, echo=TRUE, warnings=FALSE, message=FALSE, fig.align='center', fig.width=8 }
ggplot2::ggplot(data = datos.sin.faltantes) +
  ggplot2::geom_boxplot(mapping = ggplot2::aes(y = price/1000, fill = property_type)) +
  ggplot2::facet_wrap(~ property_type, nrow = 1, scales = "free") +
  ggplot2::labs(y = "Precio (en miles de USD)",
                title = "Boxplots de precio por tipo de propiedad",
                fill = "Tipo de propiedad") +
  ggplot2::theme_bw() +
  ggplot2::theme(
    legend.position = "bottom",
    plot.title = ggplot2::element_text(hjust = 0.5),
    plot.subtitle = ggplot2::element_text(hjust = 0.5),
    axis.title.x = ggplot2::element_blank(),
    axis.text.x = ggplot2::element_blank(),
    axis.ticks.x = ggplot2::element_blank()
  )
```

Finalmente, realizamos un correlograma de las variables numéricas. Aquí se observa que también hay valores muy atípicos en los atributos *surface_covered* y *surface_total*. Éstos también los vamos a tener que tratar para obtener un buen ajuste de los modelos lineales.

```{r, echo=TRUE, warnings=FALSE, message=FALSE, fig.align='center', fig.width=10 }
datos.numericos <- datos.sin.faltantes %>%
  dplyr::select(dplyr::one_of(variables.numericas))

GGally::ggpairs(data = datos.numericos,
                lower = list(continuous = GGally::wrap("points", alpha = 0.3,    size=0.1),
                             combo = GGally::wrap("dot", alpha = 0.4,            size=0.2) )) +
  ggplot2::labs(title = "Asociación de variables tomadas de a pares", x = "", y = "") +
  ggplot2::theme_bw() +
  ggplot2::theme(
    legend.position = "bottom",
    plot.title = ggplot2::element_text(hjust = 0.5),
    plot.subtitle = ggplot2::element_text(hjust = 0.5)
  )
```

# Tratamiento de outliers

El trabajo práctico propone tratar los outliers de la variable **precio**. Sin embargo, por sí sola esa variable no nos indica si el outlier es un error de carga o no. Tampoco sería bueno dejar de lado lo observado anteriormente para los atributos relacionados con la superficie. Por tal motivo se propone un análisis de outliers con la siguiente lógica:

  * Eliminar aquellas propiedades cuya superficie exceda los 10.000 m<sup>2</sup> (dado que implicaría que la propiedad ocupa más de una manzana, lo cual es algo bastante atípico de por sí). El atributo a utilizar es *surface_total*.
  * Luego se agregará un atributo que indique el precio de la propiedad por m<sup>2</sup>. Por la lógica del negocio, se sabe que ambas variables están relacionadas, si bien existe varianza explicada por otras variables (tipo de propiedad, zona, etc.). Eliminamos las propiedades cuyo valuación sea menor a USD 100/m<sup>2</sup> o mayor a USD 15.000/m<sup>2</sup> por considerarlas asbolutamente atípicas.
  * A continuación, se adicionará otra variable que sea la relación de superficie cubierta sobre la superficie total. La superficie cubierta siempre es menor a la superficie total. Por tal motivo, se eliminarán observaciones donde esta razón sea mayor a 1.
  * Por último, de las observaciones restantes, se eliminarán aquellas con valores de precios muy extremos tomando como valores de corte los outliers resultantes de *boxplots* por tipo de propiedad con *rango* = 3 (los cuales se consideran observaciones muy atípicas).

```{r, echo=TRUE, warnings=FALSE, message=FALSE, fig.align='center', fig.width=10 }
# Filtrado de observaciones según los criterios 1 a 3.
datos.filtrados <- datos.sin.faltantes %>%
  dplyr::mutate(precio_superficie = price / surface_total,
                razon_superficie_cubierta = surface_covered / surface_total) %>%
  dplyr::filter(surface_total < 10000,
                precio_superficie > 100 & precio_superficie < 15000,
                razon_superficie_cubierta <= 1)

# Cálculo de valores de corte para el precio por tipo de propiedad
datos.sin.outliers <- purrr::map_dfr(
  .x = unique(datos.filtrados$property_type),
  .f = function(tipo) {
    datos.tipo.propiedad <- datos.filtrados %>%
      dplyr::filter(property_type == tipo)
    cuartiles     <- quantile(datos.tipo.propiedad$price, probs = c(0.25, 0.75))
    Q1            <- cuartiles[1]
    Q3            <- cuartiles[2]
    
    return (datos.tipo.propiedad %>%
      dplyr::filter(
        (price >= Q1 - 3 * (Q3 - Q1)) &
        (price <= Q3 + 3 * (Q3 - Q1))
      )
    )
  }
)
```

# Analisis exploratorios (III)

Luego de haber eliminado los outliers de acuerdo al mecanismo descripto anteriormente, volvemos a realizar los mismos análisis exploratorios. Calculamos estadísticas descriptivas para la variable **precio** y realizamos un histograma de su distribución.

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
# Realizamos una tabla con las estadísticas descriptivas
cuartiles.precio                 <- quantile(datos.sin.outliers$price, 
                                             probs = c(0.25, 0.5, 0.75))
estadisticas.descriptivas.precio <- datos.sin.outliers %>%
  dplyr::summarise(
    Mínimo = min(price), 
    Q1 = cuartiles.precio[1], 
    Mediana = cuartiles.precio[2],
    Media = mean(price), 
    Q3 = cuartiles.precio[3],
    Máximo = max(price)
  )

knitr::kable(
  x = estadisticas.descriptivas.precio,
  digits = 3
)
```

```{r, echo=TRUE, warnings=FALSE, message=FALSE, fig.align='center', fig.width=8 }
# Y ahora el histograma
ggplot2::ggplot(data = datos.sin.outliers) +
  ggplot2::geom_histogram(mapping = ggplot2::aes(x = price/1000), 
                          fill = "darkslategray4") +
  ggplot2::labs(x = "Precio (en miles de USD)", y = "Frecuencia", 
                title = "Histograma para la variable precio (sin outliers)") +
  ggplot2::theme_bw() +
  ggplot2::theme(
    plot.title = ggplot2::element_text(hjust = 0.5),
    plot.subtitle = ggplot2::element_text(hjust = 0.5),
  )
```

Ahora calculamos las estadísticas descriptivas agrupando por **property_type**.

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
# Realizamos una tabla con las estadísticas descriptivas
estadisticas.descriptivas.precio.tipo.propiedad <- purrr::map_dfr(
  .x = unique(datos.sin.outliers$property_type),
  .f = function(tipo_propiedad) {
    datos.tipo.propiedad                  <- datos.sin.outliers %>%
      dplyr::filter(property_type == tipo_propiedad)
    cuartiles.precio.tipo                 <- quantile(datos.tipo.propiedad$price,
                                                      probs = c(0.25, 0.5, 0.75))
    estadisticas.descriptivas.precio.tipo <- datos.tipo.propiedad %>%
      dplyr::summarise(
        Tipo = tipo_propiedad,
        Mínimo = min(price), 
        Q1 = cuartiles.precio.tipo[1], 
        Mediana = cuartiles.precio.tipo[2],
        Media = mean(price), 
        Q3 = cuartiles.precio.tipo[3],
        Máximo = max(price)
      )
  }
)

knitr::kable(
  x = estadisticas.descriptivas.precio.tipo.propiedad,
  digits = 3
)
```

Para cada tipo de propiedad, elaboramos un boxplot.

```{r, echo=TRUE, warnings=FALSE, message=FALSE, fig.align='center', fig.width=8 }
ggplot2::ggplot(data = datos.sin.outliers) +
  ggplot2::geom_boxplot(mapping = ggplot2::aes(y = price/1000, fill = property_type)) +
  ggplot2::facet_wrap(~ property_type, nrow = 1, scales = "free") +
  ggplot2::labs(y = "Precio (en miles de USD)",
                title = "Boxplots de precio por tipo de propiedad",
                fill = "Tipo de propiedad") +
  ggplot2::theme_bw() +
  ggplot2::theme(
    legend.position = "bottom",
    plot.title = ggplot2::element_text(hjust = 0.5),
    plot.subtitle = ggplot2::element_text(hjust = 0.5),
    axis.title.x = ggplot2::element_blank(),
    axis.text.x = ggplot2::element_blank(),
    axis.ticks.x = ggplot2::element_blank()
  )
```

Finalmente, realizamos un correlograma de las variables numéricas.

```{r, echo=TRUE, warnings=FALSE, message=FALSE, fig.align='center', fig.width=10 }
datos.numericos <- datos.sin.outliers %>%
  dplyr::select(dplyr::one_of(variables.numericas))

GGally::ggpairs(data = datos.numericos,
                lower = list(continuous = GGally::wrap("points", alpha = 0.3,    size=0.1),
                             combo = GGally::wrap("dot", alpha = 0.4,            size=0.2) )) +
  ggplot2::labs(title = "Asociación de variables tomadas de a pares", x = "", y = "") +
  ggplot2::theme_bw() +
  ggplot2::theme(
    legend.position = "bottom",
    plot.title = ggplot2::element_text(hjust = 0.5),
    plot.subtitle = ggplot2::element_text(hjust = 0.5)
  )
```

# Modelo lineal

Efectuamos los modelos lineales simples solicitados para predecir la variable **precio**. El primero, basado en la cantidad de habitaciones (*rooms*) y el segundo, en función de la superficie total (*surface_total*). Adicionalmente, si bien no es pedido dentro de las consignas, se agrega otro modelo basado en la superficie cubierta (*surface_covered*), ya que se observa que por su correlación es el mejor atributo para predecir el precio.

```{r, echo=TRUE, warnings=FALSE, message=FALSE, fig.align='center', fig.width=8 }
modelo.habitaciones <- stats::lm(formula = price ~ rooms, data = datos.sin.outliers)
summary(modelo.habitaciones)
```

```{r, echo=TRUE, warnings=FALSE, message=FALSE, fig.align='center', fig.width=8 }
ggplot2::ggplot(data = datos.sin.outliers, mapping = ggplot2::aes(x = rooms, y = price)) +
  ggplot2::geom_point() +
  ggplot2::geom_smooth(method = "lm", se = TRUE) +
  ggpubr::stat_regline_equation(mapping = ggplot2::aes(label =  paste(..eq.label.., ..adj.rr.label.., sep = "~~~~")), 
                                label.y = 2e6) +
  ggplot2::labs(x = "Cantidad de habitaciones", y = "Precio (USD)",
                title = "Modelo lineal para precio de inmuebles",
                subtitle = "Precio basado en cantidad de habitaciones") +
  ggplot2::theme_bw() +
  ggplot2::theme(
    plot.title = ggplot2::element_text(hjust = 0.5),
    plot.subtitle = ggplot2::element_text(hjust = 0.5)
  )
```

```{r, echo=TRUE, warnings=FALSE, message=FALSE, fig.align='center', fig.width=8 }
modelo.superficie.total <- stats::lm(formula = price ~ surface_total, data = datos.sin.outliers)
summary(modelo.superficie.total)
```

```{r, echo=TRUE, warnings=FALSE, message=FALSE, fig.align='center', fig.width=8 }
ggplot2::ggplot(data = datos.sin.outliers, mapping = ggplot2::aes(x = surface_total, y = price)) +
  ggplot2::geom_point() +
  ggplot2::geom_smooth(method = "lm", se = TRUE) +
  ggpubr::stat_regline_equation(mapping = ggplot2::aes(label =  paste(..eq.label.., ..adj.rr.label.., sep = "~~~~")), 
                                label.y = 2e+6) +
  ggplot2::labs(x = "Superficie (metros cuadrados)", y = "Precio (USD)",
                title = "Modelo lineal para precio de inmuebles",
                subtitle = "Precio basado en superficie") +
  ggplot2::theme_bw() +
  ggplot2::theme(
    plot.title = ggplot2::element_text(hjust = 0.5),
    plot.subtitle = ggplot2::element_text(hjust = 0.5)
  )
```

```{r, echo=TRUE, warnings=FALSE, message=FALSE, fig.align='center', fig.width=8 }
modelo.superficie.cubierta <- stats::lm(formula = price ~ surface_covered, data = datos.sin.outliers)
summary(modelo.superficie.cubierta)
```

```{r, echo=TRUE, warnings=FALSE, message=FALSE, fig.align='center', fig.width=8 }
ggplot2::ggplot(data = datos.sin.outliers, mapping = ggplot2::aes(x = surface_covered, y = price)) +
  ggplot2::geom_point() +
  ggplot2::geom_smooth(method = "lm", se = TRUE) +
  ggpubr::stat_regline_equation(mapping = ggplot2::aes(label =  paste(..eq.label.., ..adj.rr.label.., sep = "~~~~")), 
                                label.y = 2e+6) +
  ggplot2::labs(x = "Superficie cubierta (metros cuadrados)", y = "Precio (USD)",
                title = "Modelo lineal para precio de inmuebles",
                subtitle = "Precio basado en superficie") +
  ggplot2::theme_bw() +
  ggplot2::theme(
    plot.title = ggplot2::element_text(hjust = 0.5),
    plot.subtitle = ggplot2::element_text(hjust = 0.5)
  )
```

Tal como se observa, de los dos modelos pedidos, el que mejor ajusta el precio es el basado en superficie total. Incluso, el basado en superficie cubierta ajusta mejor aún todavía. La fundamientación de esta aserveración está basada en la inspección del R<sup>2</sup> resultante del ajuste.