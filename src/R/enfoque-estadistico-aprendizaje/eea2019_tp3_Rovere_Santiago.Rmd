---
title: "Enfoque estadístico del aprendizaje: Trabajo Práctico nº 3"
subtitle: "Regresión logística"
author:
- Santiago Rovere (srovere@gmail.com), Facultad de Ingeniería, Universidad de Buenos Aires
date: '`r format(Sys.Date(), "%d de %B de %Y")`'
output:
  html_document:
    toc: TRUE
    toc_float: TRUE
    theme: flatly
    css: styles.css
lang: es
---

# Preparación de los datos

Se comienza el análisis propuesto cargando los paquetes necesarios, leyendo el conjunto de datos y mostrando la estructura del mismo a fin de conocer los atributos sobre los que se van a trabajar.

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
# Borrar variables del ambiente
rm(list = objects())

# Carga de paquetes necesarios para hacer los gráficos
require(Cairo)
require(caret)
require(cowplot)
require(GGAlly)
require(ggpubr)
require(highcharter)
require(Hmisc)
require(knitr)
require(magrittr)
require(modelr)
require(pROC)
require(tidyverse)

# Uso de Cairo para renderizar los gráficos.
options(bitmapType = "cairo")

# Cargar conjunto de datos deo sobrevivientes del Titanic
datos_train <- readr::read_csv(file = "titanic_complete_train.csv")

# Mostrar estructura
head(datos_train)
```

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
datos_train %<>%
  # Seleccionar las variables PassengerId, Survived, Pclass, Sex, Age, SibSp,Parch, Fare y Embarked  
  dplyr::select(PassengerId, Survived, Pclass, Sex, Age, SibSp,Parch, Fare, Embarked) %>%
  # Transformar las variables Survived, Pclass, Sex y Embarked a factor
  dplyr::mutate(Survived = as.factor(Survived), 
                Pclass = as.factor(Pclass),
                Sex = as.factor(Sex),
                Embarked = as.factor(Embarked))
```

```{r, echo=TRUE, warnings=FALSE, message=FALSE, fig.width=8, fig.height=10 }
GGally::ggpairs(data = datos_train,
                mapping = ggplot2::aes(col = Survived),
                columns = which(colnames(datos_train) %in% c("Pclass", "Sex", "Age", "Fare"))) +
  ggplot2::theme_bw() +
  ggplot2::theme(
    legend.position = 'bottom',
    axis.text.x = element_text(angle = 90, hjust = 1)
  ) 
```

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
# Dividir el conjunto de entrenamiento en 70% para entrenamiento y 30% para validacion.
# Se define una semilla para que el ejemplo sea reproducible.
set.seed(0)
entrenamiento_validacion <- datos_train %>% 
  modelr::resample_partition(c(train = 0.7, test = 0.3))
datos_entrenamiento <- entrenamiento_validacion$train %>%
  as_tibble()
datos_validacion <- entrenamiento_validacion$test %>% 
  as_tibble()

# Analizar distribución de clase para verificar que se preserven las proporciones
datos.grafico.proporcion.clase <- dplyr::bind_rows(
  datos_train %>% dplyr::mutate(Conjunto = "Original de entrenamiento"),
  datos_entrenamiento %>% dplyr::mutate(Conjunto = "Entrenamiento (70%)"),
  datos_validacion %>% dplyr::mutate(Conjunto = "Validación (30%)")) %>%
  dplyr::mutate(Survived = dplyr::case_when(Survived == 0 ~ "No sobrevivió",
                                            TRUE ~ "Sobrevivió"),
                Conjunto = factor(Conjunto, levels = c("Original de entrenamiento", "Entrenamiento (70%)", "Validación (30%)"))) %>%
  dplyr::group_by(Conjunto) %>%
  dplyr::mutate(Total = dplyr::n()) %>%
  dplyr::group_by(Conjunto, Survived, Total) %>%
  dplyr::summarise(Cantidad = dplyr::n()) %>%
  dplyr::mutate(Porcentaje = 100 * Cantidad / Total)
  
highcharter::highchart() %>%
  highcharter::hc_add_series(data = datos.grafico.proporcion.clase, type = "column",
                             mapping = highcharter::hcaes(x = Conjunto, y = Porcentaje, group = Survived)) %>%
  highcharter::hc_colors(c("#e31a1c", "#1f78b4")) %>%
  highcharter::hc_xAxis(title = list(text = "Conjunto de datos"), type = "category", 
                        categories = unique(datos.grafico.proporcion.clase$Conjunto)) %>%
  highcharter::hc_yAxis(title = list(text = "Porcentaje de datos en la clase"), min = 0, max = 100) %>%
  highcharter::hc_tooltip(valueDecimals = 2, valueSuffix = ' %') %>%
  highcharter::hc_title(text = "Distribución de clases por conjunto de datos")
```

# Predicciones 

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
# Se realiza el primer modelo con las variables Pclass, Sex y Age
modelo.1 <- glm(formula = Survived ~ Pclass + Sex + Age, family = 'binomial', data = datos_entrenamiento)
knitr::kable(
  broom::tidy(modelo.1)
)
```

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
# Ahora se reponde a la pregunta: Quien tiene mas chances de sobrevivir?
prob.rose <- predict(object = modelo.1, 
                     newdata = data.frame(Pclass = factor(1, levels = levels(datos_entrenamiento$Pclass)), 
                                          Sex = factor("female", levels = levels(datos_entrenamiento$Sex)),
                                          Age = 17), type = "response")
prob.jack <- predict(object = modelo.1, 
                     newdata = data.frame(Pclass = factor(3, levels = levels(datos_entrenamiento$Pclass)), 
                                          Sex = factor("male", levels = levels(datos_entrenamiento$Sex)),
                                          Age = 20), type = "response")
```

# Generación de modelos

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
# Se defines las formulas para los 3 modelos a analizar
formulas.modelos <- modelr::formulas(.response = ~Survived,
                                     sexo_tarifa_edad = ~Sex + Fare + Age,
                                     tarifa_lugar = ~Fare + Embarked,
                                     sexo_clase_lugar_edad = ~ Sex + Pclass + Embarked + Age)

# Generar modelos en base a las formulas
modelos <- dplyr::data_frame(formulas.modelos) %>% 
  # Generar features con el modelo y la expresion del mismo
  dplyr::mutate(Expresion = paste(formulas.modelos),
                Nombre = names(formulas.modelos),
                Modelo = purrr::map(formulas.modelos, ~glm(.,family = 'binomial', data = datos_entrenamiento))) %>%
  # Seleccionar Expresion y Modelo
  dplyr::select(Expresion, Nombre, Modelo) %>%
  # Agregar modelo inicial
  dplyr::bind_rows(tibble::tibble(Expresion = "Survived ~ Pclass + Sex + Age", Modelo = list(modelo.1)))

# Mostrar los modelos ordenados por el deviance de cada uno de ellos
modelos %>% 
  dplyr::mutate(glance = purrr::map(Modelo, broom::glance)) %>%
  tidyr::unnest(glance) %>%
  dplyr::select(Expresion, deviance, null.deviance, logLik, AIC, BIC) %>%
  dplyr::arrange(deviance)
```

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
# Generamos la curva ROC y calculamos ROC AUC para el modelo elegido (sexo_clase_lugar_edad)
prediccion.mejor.modelo <- modelos %>% 
  dplyr::filter(Nombre == "sexo_clase_lugar_edad") %>% 
  dplyr::mutate(pred = purrr::map(Modelo, broom::augment, type.predict = "response")) %>%
  tidyr::unnest(pred, .drop=TRUE)

# Calcular ROC
roc.mejor.modelo <- pROC::roc(response = prediccion.mejor.modelo$Survived, predictor = prediccion.mejor.modelo$.fitted)
```

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
# Graficar ROC
pROC::ggroc(roc.mejor.modelo, size=1) + 
  ggplot2::geom_abline(slope = 1, intercept = 1, linetype='dashed') + 
  ggplot2::theme_bw() + 
  ggplot2::labs(title='Curvas ROC', color='Modelo')
```

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
# Violing plot
ggplot2::ggplot(data = prediccion.mejor.modelo, 
                mapping = ggplot2::aes(x = Survived, y = .fitted, group = Survived, fill = Survived)) + 
  ggplot2::geom_violin() +
  ggplot2::labs(title = 'Gráfico de violín', subtitle = 'Modelo basado en sexo, clase, lugar de embarcación y edad', 
                y = 'Probabilidad predicha') +
  ggplot2::theme_bw() + 
  ggplot2::theme(
    legend.position = 'bottom',
    plot.title = ggplot2::element_text(hjust = 0.5),
    plot.subtitle = ggplot2::element_text(hjust = 0.5)
  )
```

```{r, echo=TRUE, warnings=FALSE, message=FALSE }
# Prediccion utilizando conjunto de validacion
prediccion.validacion <- modelos %>% 
  dplyr::filter(Nombre == "sexo_clase_lugar_edad") %>% 
  dplyr::mutate(pred = purrr::map(Modelo, predict, newdata = dplyr::select(datos_validacion, -Survived), 
                                  type = "response")) %>%
  tidyr::unnest(pred, .drop=TRUE) %>%
  dplyr::pull(pred)
clases.validacion <- datos_validacion %>%
  dplyr::mutate(Clase = as.integer(as.character(Survived))) %>%
  dplyr::pull(Clase)

# Definir metricas de prediccion en funcion de un umbral de corte
MetricasPrediccion <- function(probabilidades, clase, umbral.corte) {
  predicciones     <- ifelse(probabilidades > umbral.corte, 1, 0)
  matriz.confusion <- caret::confusionMatrix(
    table(as.character(predicciones), as.character(clase)), 
  positive = "1")
  
  broom::tidy(matriz.confusion) %>%
    dplyr::select(term, estimate) %>%
    dplyr::filter(term %in% c('accuracy', 'sensitivity', 'specificity', 'precision','recall')) %>%
    dplyr::mutate(umbral = umbral.corte)
}

# Calcular metricas
metricas <- purrr::map_dfr(
  .x = seq(from = 0.03, to = 0.96, by = 0.001),
  .f = function(umbral.corte) {
    MetricasPrediccion(prediccion.validacion, clases.validacion, umbral.corte = umbral.corte)
  }
)

ggplot2::ggplot(data = metricas, 
                mapping = ggplot2::aes(x = umbral, y = estimate, group = term, color = term)) + 
  ggplot2::geom_line(size = 1) +
  ggplot2::theme_bw() +
  ggplot2::labs(title = 'Accuracy, Sensitivity, Specificity, Recall y Precision', 
                subtitle = 'Modelo basado en sexo, clase, lugar de embarcación y edad', 
                col = "Métrica")
```