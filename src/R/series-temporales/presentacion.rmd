---
title: "Control de calidad de datos de temperatura máxima"
subtitle: "Series Temporales - Trabajo práctico final"
runtime: shiny
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
---


```{r global, include=FALSE}
require(automap)
require(Cairo)
require(dplyr)
require(gstat)
require(highcharts)
require(httr)
require(jsonlite)
require(leaflet)
require(leafem)
require(purrr)
require(raster)
require(sf)
require(stlplus)
require(stars)
require(tidyr)

# Carga de shape de Argentina
argentina  <- base::readRDS("data/gadm36_ARG_0_sf.rds")

# Carga de datos para imputacion
load("data/SeriesInterpoladas.RData")
estaciones.estudio <- estaciones.estudio %>%
  dplyr::arrange(nombre)
```

Detección de anomalías
=======================================================================

Imputación de faltantes
=======================================================================

Inputs {.sidebar}
-----------------------------------------------------------------------

Seleccione la estación para realizar la descomposición STL aditiva de su serie temporal de temperal de temperatura máxima.

```{r}
opcionesEstacionesImputacion        <- dplyr::pull(estaciones.estudio, omm_id)
names(opcionesEstacionesImputacion) <- dplyr::pull(estaciones.estudio, nombre)
shiny::selectInput(inputId = "estacionImputacionId",
                   label = shiny::div(icon("globe", lib = "glyphicon"), span(style = "padding-left: 5px;", "Estación")), 
                   choices = opcionesEstacionesImputacion)
```

Indique una fecha para la cual desee realizar la interpolación espacial del residuo de temperatura máxima.

```{r}
shiny::dateInput(inputId = "fechaInterpolacion",
                 label = shiny::div(icon("calendar", lib = "glyphicon"), span(style = "padding-left: 5px;", "Fecha para interpolación")), 
                 min = min(series.interpoladas$fecha), max = max(series.interpoladas$fecha), 
                 value = as.Date("2006-06-15"), language = "es")
```

Column
-----------------------------------------------------------------------

### Descomposición STL aditiva de serie temporal de temperatura máxima

```{r}
highcharter::renderHighchart({
  serie.estacion <- series.interpoladas %>%
    dplyr::filter(omm_id == as.integer(input$estacionImputacionId)) %>%
    dplyr::mutate(color = factor(dplyr::if_else(! is.na(valor), "Real", "Imputado"), levels = c("Real", "Imputado"))) %>%
    dplyr::select(fecha, color, seasonal, trend, remainder, valor_interpolado) %>%
    tidyr::pivot_longer(cols = c(seasonal, trend, remainder, valor_interpolado), names_to = 'variable', values_to = 'valor') %>%
    dplyr::mutate(componente = factor(
      dplyr::case_when(
        variable == "trend" ~ "Tendencia",
        variable == "seasonal" ~ "Estacionalidad",
        variable == "remainder" ~ "Residuo",
        TRUE ~ "Serie completa"
      ), levels = c("Tendencia", "Estacionalidad", "Residuo", "Serie completa")
    ))
    
  shiny::withProgress({
    highcharter::highchart() %>%
      highcharter::hc_add_series(data = serie.estacion, type = "line", visible = TRUE, showInLegend = TRUE,
                                 mapping = highcharter::hcaes(x = fecha, y = valor, group = componente)) %>%
      highcharter::hc_xAxis(type = 'datetime', title = list(text = "Fecha")) %>%
      highcharter::hc_yAxis(title = list(text = "Valor (ºC)")) %>%
      highcharter::hc_chart(type = 'line', zoomType = 'x', panning = TRUE, panKey = 'shift') %>%
      highcharter::hc_legend(enabled = TRUE, layout = "horizontal") %>%
      highcharter::hc_tooltip(shared = TRUE, valueDecimals = 2) %>%
      highcharter::hc_colors(c('#e6ab02','#1b9e77','#377eb8','#e41a1c')) %>%
      highcharter::hc_title(text = "Descomposición STL aditiva de temperatura máxima") %>%
      highcharter::hc_exporting(enabled = TRUE) %>%
      highcharter::hc_add_theme(highcharter::hc_theme_flat()) %>%
      highcharter::hc_plotOptions(
        line = list(cursor = 'pointer'),
        series = list(
          marker = list(
            enabled = F
          )
        )
      )
  }, value = NULL, message = "Realizando descomposición STL...")
})
```

Column
-----------------------------------------------------------------------

### Interpolación espacial de residuos de temperatura máxima

```{r}
leaflet::renderLeaflet({
  # Obtener residuos para fecha seleccionada
  residuos <- estaciones.estudio %>%
  dplyr::inner_join(
    dplyr::filter(series.interpoladas, fecha == input$fechaInterpolacion),
    by = c("omm_id")
  )
  
  shiny::withProgress({
    locations  <- dplyr::filter(residuos, ! is.na(remainder))
    variograma <- gstat::variogram(remainder ~ 1, data = locations)
    modelo     <- automap::autofitVariogram(formula = remainder ~ 1, input_data = sf::as_Spatial(locations))
    kriging    <- gstat::krige(remainder ~ 1, locations = locations, newdata = residuos, model = modelo$var_model) %>%
      dplyr::rename(residuo_prediccion = var1.pred, varianza = var1.var) %>%
      dplyr::mutate(omm_id = dplyr::pull(residuos, omm_id), residuo_original = dplyr::pull(residuos, remainder), 
                    error = residuo_prediccion - residuo_original)
  
    # Se genera el raster interpolado
    grilla.regular <- sf::st_make_grid(x = argentina, what = "centers", cellsize = c(0.1, 0.1))
    kriging.grilla <- gstat::krige(remainder ~ 1, locations = locations, newdata = grilla.regular, model = modelo$var_model)
    kriging.arg    <- as(stars::st_rasterize(sf = kriging.grilla), "Raster") %>%
      raster::mask(x = ., mask = argentina)
    
    # Dibujar mapa
    valores.interpolados <- raster::values(kriging.arg)
    paleta.kriging       <- leaflet::colorBin(palette = "RdYlBu", domain = valores.interpolados, bins = 8,
                                              na.color = "transparent", reverse = TRUE)
    
    leaflet::leaflet(data = locations) %>%
      leafem::addMouseCoordinates() %>%
      leaflet::addTiles(map = ., urlTemplate = "//{s}.tiles.mapbox.com/v3/jcheng.map-5ebohr46/{z}/{x}/{y}.png") %>%
      leaflet::addRasterImage(x = kriging.arg, colors = paleta.kriging, group = "Kriging", layerId = "Kriging") %>%
      leaflet::addCircleMarkers(map = ., label = ~sprintf("%s", nombre), radius = 5, color = "black", fillColor = "black",
                                weight = 1, labelOptions = leaflet::labelOptions(noHide = F, textOnly = TRUE, style = list(
          "color" = "red",
          "font-weight" = "bold",
          "box-shadow" = "3px 3px rgba(0,0,0,0.25)",
          "font-size" = "12px",
          "border-color" = "rgba(0,0,0,0.5)"
        )
      )) %>%
      leafem::addImageQuery(map = ., x = kriging.arg, type = "mousemove", digits = 2, prefix = "Residuo",
                        group = "Kriging", layerId = "Kriging") %>%
      leaflet::addLegend(position = "bottomright", pal = paleta.kriging, values = valores.interpolados,
                     title = "Residuos (ºC)", opacity = 1)
    
  }, value = NULL, message = "Realizando proceso de kriging...")
})
```

Clustering
=======================================================================

Inputs {.sidebar}
-----------------------------------------------------------------------

Indique la cantidad de _grupos_ para realizar el clustering.

```{r}
shiny::sliderInput(inputId = "cantidadClusters",
                   label = shiny::div(icon("scale", lib = "glyphicon"), span(style = "padding-left: 5px;", "Cantidad de grupos")), 
                   min = 3, max = 15, step = 1, value = 8)
```